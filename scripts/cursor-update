#!/usr/bin/env bash
set -euo pipefail

# Re-exec as root if needed
if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
  exec sudo -E "$0" "$@"
fi

need() { command -v "$1" >/dev/null 2>&1 || { echo "‚ùå Missing dependency: $1"; exit 1; }; }

need curl

ARCH="$(uname -m)"
case "$ARCH" in
  x86_64)  PLATFORM="linux-x64" ;;
  aarch64|arm64) PLATFORM="linux-arm64" ;;
  *)
    echo "‚ùå Unsupported arch: $ARCH"
    exit 1
    ;;
esac

TRACK="${1:-stable}"  # usage: update-cursor [stable|insiders]
API_URL="https://www.cursor.com/api/download?platform=${PLATFORM}&releaseTrack=${TRACK}"

echo "‚û°Ô∏è  Cursor update (platform=${PLATFORM}, track=${TRACK})"
echo "‚û°Ô∏è  API: ${API_URL}"

JSON="$(curl -fsSL --retry 5 --retry-delay 2 --connect-timeout 10 --max-time 60 "$API_URL" || true)"

if [[ -z "${JSON}" ]]; then
  echo "‚ùå Empty response from API."
  exit 1
fi

# Parse downloadUrl reliably:
DOWNLOAD_URL=""

# Preferred: python (if available)
if command -v python3 >/dev/null 2>&1; then
  DOWNLOAD_URL="$(
    JSON="$JSON" python3 -c '
import os, json
data = json.loads(os.environ["JSON"])
print(data.get("downloadUrl",""))
' 2>/dev/null || true
  )"
fi

# Fallback: grep/sed (no python)
if [[ -z "${DOWNLOAD_URL}" ]]; then
  DOWNLOAD_URL="$(
    printf '%s' "$JSON" | sed -n 's/.*"downloadUrl"[[:space:]]*:[[:space:]]*"\([^"]\+\)".*/\1/p' | head -n1
  )"
fi

if [[ -z "$DOWNLOAD_URL" || "$DOWNLOAD_URL" != http* ]]; then
  echo "‚ùå Could not parse download URL from API response."
  echo "API response was:"
  echo "$JSON"
  exit 1
fi

echo "‚úÖ Download URL: $DOWNLOAD_URL"

INSTALL_DIR="/opt/cursor"
APPIMAGE_PATH="${INSTALL_DIR}/cursor.AppImage"
BIN_LINK="/usr/local/bin/cursor"

TMPDIR="$(mktemp -d)"
trap 'rm -rf "$TMPDIR"' EXIT

TMP_APP="${TMPDIR}/cursor.AppImage"

echo "‚¨áÔ∏è  Downloading..."
curl -fL --retry 5 --retry-delay 2 --connect-timeout 10 --max-time 600 \
  -o "$TMP_APP" "$DOWNLOAD_URL"

chmod +x "$TMP_APP"

mkdir -p "$INSTALL_DIR"

# Backup existing
if [[ -f "$APPIMAGE_PATH" ]]; then
  TS="$(date +%Y%m%d-%H%M%S)"
  cp -a "$APPIMAGE_PATH" "${APPIMAGE_PATH}.bak-${TS}"
  echo "üóÇÔ∏è  Backup: ${APPIMAGE_PATH}.bak-${TS}"
fi

mv -f "$TMP_APP" "$APPIMAGE_PATH"
ln -sf "$APPIMAGE_PATH" "$BIN_LINK"

# Extract and install icon from AppImage if possible
ICON_DIR="/usr/share/pixmaps"
ICON_PATH="${ICON_DIR}/cursor.png"
if [[ -f "$APPIMAGE_PATH" ]]; then
  EXTRACT_DIR="${TMPDIR}/appimage_extract"
  mkdir -p "$EXTRACT_DIR"
  EXTRACTED_ICON=""
  
  # Method 1: Try extracting from squashfs (most reliable)
  if command -v unsquashfs >/dev/null 2>&1; then
    if unsquashfs -d "$EXTRACT_DIR" -f "$APPIMAGE_PATH" .DirIcon 2>/dev/null; then
      if [[ -f "$EXTRACT_DIR/.DirIcon" ]]; then
        EXTRACTED_ICON="$EXTRACT_DIR/.DirIcon"
      fi
    fi
  fi
  
  # Method 2: Try AppImage's --appimage-extract (extracts to current dir, so we cd to tmpdir)
  if [[ -z "$EXTRACTED_ICON" ]]; then
    OLD_PWD="$PWD"
    cd "$TMPDIR" || true
    if "$APPIMAGE_PATH" --appimage-extract .DirIcon 2>/dev/null; then
      if [[ -f "$TMPDIR/squashfs-root/.DirIcon" ]]; then
        EXTRACTED_ICON="$TMPDIR/squashfs-root/.DirIcon"
      elif [[ -f "$TMPDIR/.DirIcon" ]]; then
        EXTRACTED_ICON="$TMPDIR/.DirIcon"
      fi
    fi
    cd "$OLD_PWD" || true
  fi
  
  # Install the extracted icon
  if [[ -n "$EXTRACTED_ICON" ]] && [[ -f "$EXTRACTED_ICON" ]]; then
    mkdir -p "$ICON_DIR"
    # Convert to PNG if needed, or copy directly
    if file "$EXTRACTED_ICON" 2>/dev/null | grep -qi "PNG\|image"; then
      cp "$EXTRACTED_ICON" "$ICON_PATH" 2>/dev/null && echo "‚úÖ Installed icon: $ICON_PATH" || true
    elif command -v convert >/dev/null 2>&1; then
      convert "$EXTRACTED_ICON" "$ICON_PATH" 2>/dev/null && echo "‚úÖ Installed icon: $ICON_PATH" || true
    else
      cp "$EXTRACTED_ICON" "$ICON_PATH" 2>/dev/null && echo "‚úÖ Installed icon: $ICON_PATH" || true
    fi
  fi
fi

echo "‚úÖ Installed: $APPIMAGE_PATH"
echo "‚úÖ Launcher:  $BIN_LINK"
echo "‚ÑπÔ∏è  Run Cursor with: cursor"

